<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Sihl_database (sihl.Sihl_database)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">sihl</a> &#x00BB; Sihl_database</nav><h1>Module <code>Sihl_database</code></h1><p>Use this module to query the database, implement and run migrations, clean repositories, turn HTTP queries into SQL queries or for sane entity identifier handling.</p><nav class="toc"><ul><li><a href="#installation">Installation</a></li><li><a href="#usage">Usage</a></li></ul></nav></header><section><header><h2 id="installation"><a href="#installation" class="anchor"></a>Installation</h2><p>The database service uses <a href="https://github.com/paurkedal/ocaml-caqti">https://github.com/paurkedal/ocaml-caqti</a> under the hood. Caqti can dynamically load the correct driver based on the <code>DATABASE_URL</code> (postgresql://).</p><p>Caqti supports following databases (caqti drivers):</p><ul><li>PostgreSQL (caqti-driver-postgresql)</li><li>MariaDB (caqti-driver-mariadb)</li><li>SQLite (caqti-driver-sqlite)</li></ul><pre><code class="ml">module Log = Sihl.Log.Service.Make ()
module Config = Sihl.Config.Service.Make (Log)
module Db = Sihl.Database.Service.Make (Config) (Log)</code></pre><p>Install one of the drivers listed above.</p><p><code>opam install caqti-driver-postgresql</code></p><p>Add the driver to your <code>done</code> file:</p><p><code>caqti-driver-postgresql</code></p></header></section><section><header><h2 id="usage"><a href="#usage" class="anchor"></a>Usage</h2><p>Register the database middleware, so other services can query the database with the context that contains the database pool.</p><pre><code class="ml">module DbMiddleware = Sihl.Web.Middleware.Db.Make (Service.Db)

let middlewares = [ DbMiddleware.m () ]</code></pre><p>The database service should be used mostly in repositories and not in services themselves.</p><p>pizza_order_repo.ml:</p><pre><code class="ml">module MakePostgreSql (DbService : Sihl.Database.Service.Sig.SERVICE) :
  Pizza_order_sig.REPO = struct
  let find_request =
    Caqti_request.find_opt
      Caqti_type.string
      Model.t
      &quot;SELECT uuid, customer, pizza, amount, status, confirmed, created_at, \
       updated_at FROM pizza_orders WHERE pizza_orders.uuid = ?::uuid&quot;
  ;;

  let find ctx ~id =
    DbService.query ctx (fun connection -&gt;
        let module Connection = (val connection : Caqti_lwt.CONNECTION) in
        Connection.find_opt get_request id |&gt; Lwt_result.map_err Caqti_error.show)
  ;;
end</code></pre><p>pizza_order_service.ml:</p><pre><code class="ml">module Make (Repo : Pizza_order_sig.REPO) : Pizza_order_sig.SERVICE = struct
  let find ctx ~id = Repo.find ctx ~id
end</code></pre><p>Then you can use the service:</p><pre><code class="ml">module PizzaOrderRepo = Pizza_order_repo.MakePostgreSql (Service.Db)
module PizzaOrderService = Pizza_order_service.Make (PizzaOrderRepo)
let get_pizza_order =
  Sihl.Web.Route.get &quot;/pizza-orders/:id&quot; (fun ctx -&gt;
      Sihl.Web.Res.(html |&gt; set_body &quot;Hello!&quot;) |&gt; Lwt.return)
let get_pizza_order =
  Sihl.Web.Route.get &quot;/pizza-orders/:id&quot; (fun ctx -&gt;
      let id = Sihl.Web.Req.param ctx &quot;id&quot; in
      let pizza = PizzaOrderService.find ctx ~id in
      ...
      )</code></pre></header><div class="spec module" id="module-Service"><a href="#module-Service" class="anchor"></a><code><span class="keyword">module</span> <a href="Service/index.html">Service</a> : <a href="Sig/index.html#module-type-SERVICE">Sig.SERVICE</a></code></div><dl><dt class="spec module" id="module-Ql"><a href="#module-Ql" class="anchor"></a><code><span class="keyword">module</span> <a href="Ql/index.html">Ql</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>A simple query language that can be used for HTTP queries that get passed into repositories. It currently supports filtering, sorting and pagination.</p></dd></dl><dl><dt class="spec module" id="module-View"><a href="#module-View" class="anchor"></a><code><span class="keyword">module</span> <a href="View/index.html">View</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Modules and helpers to handle paginated collections, which is a partial view on a list of things.</p></dd></dl><dl><dt class="spec module" id="module-Id"><a href="#module-Id" class="anchor"></a><code><span class="keyword">module</span> <a href="Id/index.html">Id</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Encode and decode entity identifiers as UUIDs.</p></dd></dl><div class="spec module" id="module-Sig"><a href="#module-Sig" class="anchor"></a><code><span class="keyword">module</span> <a href="Sig/index.html">Sig</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div></section></div></body></html>